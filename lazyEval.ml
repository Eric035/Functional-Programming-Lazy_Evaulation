(* ---------------------------------------------------- *)

(* Processing finite objects lazily is also useful;
   it corresponds to demand driving compution.
*)
(* ---------------------------------------------------- *)
(* We define next a lazy list; this list is possibly
finite; this is accomplished by a mutual recursive
  datatype.

    'a lazy_list defines a lazy list; we can observe the 
  head and its tail. For the tail we have two options:
             we have reached the end of the list indicated by the 
    constructor None or we have not reached the end 
indicated by the constructor Some and we expose
    another lazy list of which we can observe the head and the tail.  

*)

(* ---------------------------------------------------- *)         

(* 
   val take : int -> 'a lazy_list -> 'a list 
*)

let rec take n s = match n with 
  |0 -> []
  |n -> match (force s.tl) with
    |None -> [s.hd]                  (* End of list *)
    |Some y -> s.hd :: take (n - 1) (y) 


(* val map : ('a -> 'b) -> 'a lazy_list -> 'b lazy_list
*)

let rec map f s = 
  {
    hd = f (s.hd) ;
    tl = Susp (fun () -> map' f (force s.tl)) 
  }
and map' f xs = match xs with 
  |None -> None                      (* End of list we do nothing *)
  |Some y -> Some (map f y)
  
(* 
  val append : 'a lazy_list -> ('a lazy_list) option susp -> 'a lazy_list
*)

let rec append s1 s2 = 
  {
    hd = s1.hd ;
    tl = Susp (fun () -> append' (force s1.tl) (force s2))
  }
and append' s1' s2' = match s1', s2' with
  |Some y, None -> Some y 
  |None, Some y' -> Some y'
  |None, None -> None 
  |Some y, Some y' -> Some (append y (Susp (fun () -> Some y')))

(* ---------------------------------------------------- *)
(* val interleave : 'a -> 'a list -> 'a list lazy_list *)

let rec interleave x l =  match l with 
  |[] -> 
      {
        hd = [x] ; 
        tl = Susp (fun () -> None)
      }
  |h :: t -> 
      {
        hd = x :: l; 
        tl = Susp (fun () -> Some (map (fun y -> h :: y) (interleave x t)))
      } 
  
(* ---------------------------------------------------- *)
(* val flatten : 'a lazy_list lazy_list -> 'a lazy_list = <fun>
*) 
let rec flatten s = match (force s.tl) with
  |None -> s.hd
  |Some y -> append (s.hd) (Susp (fun () -> Some (flatten y)))
  
  (* let rec flatten_opt s' = match s' with 
      |None -> 
          {
            hd = s; 
            tl = None
          }
      |Some y -> 
          {
            hd = y.hd ;
            tl = Susp (fun () -> Some (append (y.hd) (flatten_opt (force s'))))
          }   *)

(* ---------------------------------------------------- *)
(* Permute : 'a list -> 'a list lazy_list *)

let rec permute l = match l with 
  |[] -> 
      {
        hd = [] ;
        tl = Susp (fun () -> None)
      }
  |x :: [] -> 
      {
        hd = [x] ;
        tl = Susp (fun () -> None)
      } 
  |h :: t -> flatten (map (interleave h) (permute t))
  

(* HailStone sequences generated by lazy programming *)
                   
let rec hailstones n = 
  {
    hd = n ;
    tl = Susp (fun () -> 
        if (n mod 2) = 0 then Some (hailstones (n / 2))
        else
          Some (hailstones (3 * n + 1)))
  }
    
    